import logging
from abc import ABC, abstractmethod
from os import environ
from typing import Any, Dict, List

LOG = logging.getLogger("exodus-lambda.config")


class LambdaConfig(ABC):
    """Abstract base class for a lambda's configuration object. Should be subclassed
    to obtain config in a specific way (e.g. config file, environment vars...)

    Any config for lambdas which can be set at deployment time should be implemented
    as a property on this class.

    Many properties have default implementations, which can be called to get a
    default value if the implementing class doesn't find a more specific value.
    """

    @property
    @abstractmethod
    def item_table(self) -> str:
        """Name of DynamoDB table containing items (URI => content mappings)."""

    @property
    @abstractmethod
    def item_table_regions(self) -> List[str]:
        """AWS region(s) at which item_table can be accessed.

        The first listed region is the preferred.
        """
        return ["us-east-1"]

    @property
    @abstractmethod
    def config_table(self) -> str:
        """Name of DynamoDB table containing volatile config blobs (e.g. rhui, releasever
        aliases)."""

    @property
    @abstractmethod
    def config_cache_ttl(self) -> int:
        """Amount of time any config loaded from config_table should be
        cached, in minutes."""
        return 2

    @property
    @abstractmethod
    def cookie_ttl(self) -> int:
        """Lifetime of cookies generated by /_/cookie endpoint, in minutes."""
        return 720

    @property
    @abstractmethod
    def cache_control_max_age(self) -> int:
        """The value of Cache-Control max-age header for pieces of content
        considered mutable (e.g. repomd.xml).

        Should be interpreted as the amount of time, in seconds, that such a
        piece of content should be cached.
        """
        return 600

    @property
    @abstractmethod
    def secret_arn(self) -> str:
        """ARN of the secret associated with this lambda (e.g. containing
        private key for generation of cookies).
        """

    @property
    @abstractmethod
    def key_id(self) -> str:
        """ID of the keypair used for signatures produced by the /_/cookies endpoint."""

    @property
    @abstractmethod
    def lambda_version(self) -> str:
        """A string identifying the current version of the lambda."""

    @property
    @abstractmethod
    def logging_config(self) -> Dict[str, Any]:
        """A logging configuration dict of the form accepted by
        logging.dictConfig."""


class DictLambdaConfig(LambdaConfig):
    """LambdaConfig implementation reading config from a plain dict (e.g. loaded
    from a JSON file).

    EnvironmentLambdaConfig is preferred. This class will be removed once all deployments
    have been given time to move to environment variables.
    """

    def __init__(self, raw):
        self._raw = raw

    @property
    def item_table(self) -> str:
        return self._raw["table"]["name"]

    @property
    def item_table_regions(self) -> List[str]:
        return self._raw["table"]["available_regions"]

    @property
    def config_table(self) -> str:
        return self._raw["config_table"]["name"]

    @property
    def config_cache_ttl(self) -> int:
        return self._raw["config_cache_ttl"]

    @property
    def cookie_ttl(self) -> int:
        return self._raw["cookie_ttl"]

    @property
    def cache_control_max_age(self) -> int:
        return self._raw["headers"]["max_age"]

    @property
    def secret_arn(self) -> str:
        return self._raw["secret_arn"]

    @property
    def key_id(self) -> str:
        return self._raw["key_id"]

    @property
    def lambda_version(self) -> str:
        return self._raw["lambda_version"]

    @property
    def logging_config(self) -> Dict[str, Any]:
        return self._raw["logging"]


class EnvironmentLambdaConfig(LambdaConfig):
    """LambdaConfig implementation reading config from environment variables."""

    @property
    def item_table(self) -> str:
        return environ["EXODUS_TABLE"]

    @property
    def item_table_regions(self) -> List[str]:
        out = [
            r for r in environ.get("EXODUS_TABLE_REGIONS", "").split(",") if r
        ]
        return out or super().item_table_regions

    @property
    def config_table(self) -> str:
        return environ["EXODUS_CONFIG_TABLE"]

    @property
    def config_cache_ttl(self) -> int:
        return int(
            environ.get("EXODUS_CONFIG_CACHE_TTL", super().config_cache_ttl)
        )

    @property
    def cookie_ttl(self) -> int:
        return int(environ.get("EXODUS_COOKIE_TTL", super().cookie_ttl))

    @property
    def cache_control_max_age(self) -> int:
        return int(
            environ.get(
                "EXODUS_HEADERS_MAX_AGE", super().cache_control_max_age
            )
        )

    @property
    def secret_arn(self) -> str:
        return environ["EXODUS_SECRET_ARN"]

    @property
    def key_id(self) -> str:
        return environ["EXODUS_KEY_ID"]

    @property
    def lambda_version(self) -> str:
        return environ.get("EXODUS_LAMBDA_VERSION", "<unknown version>")

    @property
    def logging_config(self) -> Dict[str, Any]:
        log_format = (
            environ.get("EXODUS_LOG_FORMAT")
            or "%(asctime)s - %(levelname)s - %(message)s"
        )

        loggers = {"default": {"level": "WARNING"}}

        # We support setting levels on arbitrary loggers by setting env vars of the form:
        #
        #   EXODUS_LOGGER_*=loggername loglevel
        #
        # Gather all such vars of that form.
        for varname, value in environ.items():
            varname = varname.lower()
            if varname.startswith("exodus_logger_"):
                split = value.split(" ")
                if len(split) < 2:
                    LOG.warning(
                        "Ignoring invalid logger env var: %s = %s",
                        varname,
                        value,
                    )
                else:
                    level = split[-1]
                    loggername = " ".join(split[0:-1])
                    loggers[loggername] = {"level": level.upper()}

        return {
            "version": 1,
            "incremental": True,
            "disable_existing_loggers": False,
            "formatters": {
                "default": {
                    "format": log_format,
                    "datefmt": "%Y-%m-%d %H:%M:%S",
                }
            },
            "loggers": loggers,
        }


class MixedLambdaConfig(LambdaConfig):
    """A LambdaConfig which tries to get config from one object, falling back to
    another on error.

    Intended to support mixing config files & env vars, only until config files
    (lambda_config.json) are retired completely.
    """

    def __init__(self, cfg1, cfg2):
        self.cfg1 = cfg1
        self.cfg2 = cfg2

    def _get_cfg_attr(self, name):
        try:
            return getattr(self.cfg1, name)
        except Exception:  # pylint: disable=broad-except
            LOG.debug(
                "Can't get preferred config item %s, trying fallback",
                name,
                exc_info=True,
            )
            return getattr(self.cfg2, name)

    @property
    def item_table(self):
        return self._get_cfg_attr("item_table")

    @property
    def item_table_regions(self):
        return self._get_cfg_attr("item_table_regions")

    @property
    def cache_control_max_age(self):
        return self._get_cfg_attr("cache_control_max_age")

    @property
    def config_cache_ttl(self):
        return self._get_cfg_attr("config_cache_ttl")

    @property
    def config_table(self):
        return self._get_cfg_attr("config_table")

    @property
    def cookie_ttl(self):
        return self._get_cfg_attr("cookie_ttl")

    @property
    def key_id(self):
        return self._get_cfg_attr("key_id")

    @property
    def lambda_version(self):
        return self._get_cfg_attr("lambda_version")

    @property
    def logging_config(self):
        return self._get_cfg_attr("logging_config")

    @property
    def secret_arn(self):
        return self._get_cfg_attr("secret_arn")
